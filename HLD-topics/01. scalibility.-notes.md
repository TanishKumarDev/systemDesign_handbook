# Scalability


[Vertical vs Horizontal Scaling](https://mail.google.com/mail/u/3/#search/from%3A(newsletter%40hw-mail.glich.co)+scalability/FMfcgzQcpKmXdzHgzMvzlmJPQJvBwFdB)

Scalability in system design refers to the ability of a system to handle increased load (traffic, data, users) while maintaining performance, reliability, and availability

![Scalability](https://media.geeksforgeeks.org/wp-content/uploads/20250807104547934960/vertical_and_horizontal_scaling.webp)

## Why Do We Need Scaling?

* To handle increased user load and traffic
* To ensure high availability and reliability
* To maintain performance and response time
* To support growing data and storage needs

There are two main types of scaling: **Vertical Scaling** and **Horizontal Scaling**.

---

## Vertical Scaling (Scaling Up)

Vertical scaling means increasing the power/capacity of a single machine.

### Characteristics

* Upgrade existing hardware (CPU, RAM, disk) instead of adding more machines
* Simple to implement, useful for monolithic or small-scale applications

### Examples

* Upgrading MySQL server from 16 GB RAM to 64 GB RAM
* Moving from a 2-core VM to an 8-core VM
* Running an e-commerce platform on a larger AWS EC2 instance

### Advantages

* Increased capacity (faster CPU, more RAM, etc.)
* Easier to manage (single machine focus)

### Disadvantages

* Limited scalability due to hardware limits
* Single point of failure (all requests go to one server)
* Scaling up may require downtime to replace/restart machine

---

## Horizontal Scaling (Scaling Out)

Horizontal scaling means adding more machines/servers to distribute the load.

### Characteristics

* No need to replace/upgrade existing machines
* Additional servers can be added without downtime
* Requires load balancing and distributed system design

### Examples

* GeeksforGeeks adds more web servers behind a load balancer
* Netflix scales microservices across regions
* Amazon Auto Scaling spins up more EC2 instances during peak traffic
* Cloudflare/Akamai serve content via globally distributed servers

### Advantages

* Increased capacity (multiple servers share the load)
* Better performance (reduced overload on a single machine)
* High fault tolerance (if one node fails, others take over)

### Disadvantages

* Requires complex architecture (load balancers, distributed databases)
* Maintaining strong consistency is difficult (needs replication, synchronization)
* Higher cost of networking, power, and maintenance
* Root cause analysis is harder in distributed environments
* Communication between nodes adds latency

---

## Horizontal vs Vertical Scaling

| Aspect                      | Horizontal Scaling                               | Vertical Scaling                          |
| --------------------------- | ------------------------------------------------ | ----------------------------------------- |
| **Resource Addition**       | Add more servers/machines                        | Upgrade hardware of a single server       |
| **Cost Effectiveness**      | More cost-effective for large-scale systems      | Simple initially, but expensive long-term |
| **Flexibility**             | High flexibility (easy to add units)             | Limited by hardware                       |
| **Fault Tolerance**         | High (failure handled by other nodes)            | Low (single point of failure)             |
| **Performance**             | Improves with load distribution                  | Improves until hardware limits reached    |
| **Single Point of Failure** | Less prone                                       | More prone                                |
| **Complexity**              | High (distributed systems, orchestration needed) | Low (single machine)                      |
| **Applicability**           | Best for massive scalability                     | Suitable for moderate scaling             |
| **Load Balancing**          | Required                                         | Usually not critical                      |
| **Communication**           | Network-based between distributed machines       | Mostly within single machine processes    |

---

## Which Scaling Option to Choose?

* Depends on **requirements, goals, and constraints**
* Vertical scaling → easier, good for small/medium apps
* Horizontal scaling → better for large-scale, distributed systems
* Most organizations use a **hybrid approach**:

  * Vertical scaling for speed and simplicity
  * Horizontal scaling for resilience and infinite growth

---

# Scalability Choice in System Design

We have two primary scalability methods — **Vertical Scaling** and **Horizontal Scaling**.
Choosing the right one depends on multiple factors like app architecture, cost, performance needs, and traffic patterns.

---

## Factors Affecting Scalability Choice

1. **Application Architecture**

   * Monolithic apps → Vertical scaling is simpler.
   * Microservices or distributed apps → Horizontal scaling fits better.

2. **Database Selection**

   * SQL databases → Often align with vertical scaling.
   * NoSQL databases → Designed for horizontal scaling.

3. **Cost**

   * Vertical scaling → Expensive upgrades (hardware).
   * Horizontal scaling → Cheaper long-term, pay-as-you-grow model.

4. **Security**

   * Vertical scaling → Easier control (single server, fewer points of attack).
   * Horizontal scaling → More nodes = more complexity in securing.

5. **Performance & Latency**

   * Low-latency apps (gaming, video calls) → Horizontal scaling keeps services close to users.

6. **Traffic Pattern**

   * Constant steady load → Vertical scaling works fine.
   * Highly variable/spiky load → Serverless is better (auto-scales, pay per use).

7. **Technology Stack**

   * Legacy monolithic stacks → Favor vertical scaling.
   * Container orchestration (Kubernetes, Docker) → Favor horizontal scaling.

---

## Choosing the Right Approach

### 1. Small and Steady (Low Traffic, Simple Apps)

* **Use Vertical Scaling**
* Add more CPU, RAM, or storage to a single server.
* Minimal architecture changes.
* Best for **small-scale apps** without high concurrency.

### 2. Going Big (High Growth, Microservices)

* **Use Horizontal Scaling**
* Add more servers/instances, distribute load.
* Scale individual microservices independently.
* Best for **large, growing apps** with many users.

### 3. Variable Loads (Unpredictable Traffic)

* **Use Serverless**
* Auto-scales resources depending on demand.
* Pay only for actual usage.
* Best for apps with **seasonal or spiky usage** (e.g., shopping apps, event-driven apps).

### 4. Need for Speed (Low Latency Apps)

* **Use Horizontal Scaling**
* Distribute requests across multiple servers.
* Load balancing improves response times.
* Best for **real-time apps, gaming, video calls**.

### 5. Money Matters (Budget Constraints)

* **Prefer Horizontal Scaling**
* Start with few servers and add more as needed.
* Cloud pricing models fit horizontal scaling better.
* More cost-effective for **long-term growth**.

---

## Testing Scalability

Testing ensures the chosen approach works under real-world conditions:

1. **Load Testing** – Simulate many users; check app’s response.
2. **Stress Testing** – Push app beyond normal limits; find breaking points.
3. **Load Balancer Testing** – Ensure requests are evenly distributed across servers.
4. **Database Testing** – Check read/write performance under heavy load.
5. **Failure Simulation** – Test recovery from server crashes.
6. **Monitoring** – Track real-time performance and fix issues quickly.

---

✅ **Summary:**

* **Vertical Scaling** → Simple, good for small/steady apps.
* **Horizontal Scaling** → Best for growth, speed, and reliability.
* **Serverless** → Best for unpredictable or spiky workloads.
* Real-world systems often use a **hybrid** of all three.

