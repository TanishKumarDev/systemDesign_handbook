# Stateless vs Stateful Systems in System Design

![Stateless vs Stateful](https://miro.medium.com/v2/resize:fit:1400/1*864flYMOwmV1iBjhE2ucYQ.png)
## 1. What is a Stateless System?

* A **stateless system** does not remember anything about the client after serving a request.
* Each request is **independent** and must carry **all the data** required for processing.
* Example: **REST APIs**, **Serverless functions (AWS Lambda)**.

📌 **Analogy**: Think of a **fast-food counter** (like McDonald's drive-thru).
Every time you order, you must tell them **exactly what you want**, even if you ordered the same burger yesterday. They don’t remember you.

---

## 2. What is a Stateful System?

* A **stateful system** maintains the client’s information across requests.
* The system remembers things like **login sessions, carts, preferences**.
* Example: **Databases, User Sessions, Chat applications**.

📌 **Analogy**: Think of a **restaurant waiter**.
The waiter remembers your table, what you ordered, and can bring your food step by step. You don’t repeat everything each time.

---

## 3. Diagram Representation

![Diagram](https://miro.medium.com/1*xYvS7mMWe-u3ehzm58O78A.png)
---

## 4. Real-World Examples

| System Type | Example                                                                   |
| ----------- | ------------------------------------------------------------------------- |
| Stateless   | REST API, AWS Lambda, Content Delivery Networks (CDN), JWT Authentication |
| Stateful    | Databases, Web App Sessions, Online Gaming, Messaging Apps                |

---

## 5. Code Examples

### (A) Stateless Example: REST API with Token

```cpp
#include <iostream>
#include <string>
using namespace std;

// Stateless request simulation
class StatelessAPI {
public:
    string processRequest(string request, string token) {
        if (token != "valid123") return "Unauthorized";
        return "Processed: " + request;
    }
};

int main() {
    StatelessAPI api;

    // Each request must carry the token (no memory of previous requests)
    cout << api.processRequest("Get User Data", "valid123") << endl;
    cout << api.processRequest("Update Profile", "invalid") << endl;

    return 0;
}
```

**Output:**

```
Processed: Get User Data
Unauthorized
```

👉 Here, the server does **not remember** who you are — you must prove it every time (stateless).

---

### 🔎 Code Walkthrough (Stateless API)

1. **Class design**

```cpp
class StatelessAPI {
public:
    string processRequest(string request, string token) {
        if (token != "valid123") return "Unauthorized";
        return "Processed: " + request;
    }
};
```

* This class has **no data members** (no `sessions` map like before).
* It doesn’t store anything between calls.
* Each request must carry a **token** → like an API key, JWT, or session token.
* Server only checks the token → decides request validity → responds.

---

2. **First request**

```cpp
cout << api.processRequest("Get User Data", "valid123") << endl;
```

* `token = "valid123"` ✅ → authorized.
* Returns:

```
Processed: Get User Data
```

---

3. **Second request**

```cpp
cout << api.processRequest("Update Profile", "invalid") << endl;
```

* `token = "invalid"` ❌ → unauthorized.
* Returns:

```
Unauthorized
```

---

### ⚖️ Comparison with Stateful Server

| Aspect                 | Stateful                           | Stateless                                 |
| ---------------------- | ---------------------------------- | ----------------------------------------- |
| **Memory**             | Stores `sessions[user]`            | Stores nothing                            |
| **After logout**       | User is forgotten                  | No logout needed — must always send token |
| **Request dependency** | Request depends on previous login  | Every request is independent              |
| **Example**            | Facebook session with login/logout | REST API with API key or JWT              |

---

### ✅ Why is this Stateless?

Because the server **does not remember Alice at all**.

* No `sessions` map.
* Each request is judged **only on the token provided at that moment**.
* No continuity, no "history".

---

### (B) Stateful Example: Session Tracking

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

// Stateful session simulation
class StatefulServer {
    unordered_map<string, string> sessions; // user -> sessionData
public:
    void login(string user) {
        sessions[user] = "SessionActive";
        cout << user << " logged in.\n";
    }
    void action(string user, string task) {
        if (sessions.find(user) != sessions.end())
            cout << user << " performed: " << task << endl;
        else
            cout << "No active session for " << user << endl;
    }
    void logout(string user) {
        sessions.erase(user);
        cout << user << " logged out.\n";
    }
};

int main() {
    StatefulServer server;
    server.login("Alice");
    server.action("Alice", "View Profile");
    server.logout("Alice");
    server.action("Alice", "Update Profile"); // Fails, session ended
}
```

**Output:**

```
Alice logged in.
Alice performed: View Profile
Alice logged out.
No active session for Alice
```

👉 Here, the server **remembers Alice’s session** until logout.

Great question 👍 Let’s carefully walk through your code and output to understand **why the last action fails**.

---

### 🔎 Code Walkthrough

1. **Login Alice**

```cpp
server.login("Alice");
```

* This inserts `"Alice" → "SessionActive"` into the `sessions` map.
* Now `sessions = { "Alice" : "SessionActive" }`.
* Output:

```
Alice logged in.
```

---

2. **Action: View Profile**

```cpp
server.action("Alice", "View Profile");
```

* The code checks:

```cpp
if (sessions.find("Alice") != sessions.end())
```

✅ Since `"Alice"` exists in the `sessions` map, it prints:

```
Alice performed: View Profile
```

---

3. **Logout Alice**

```cpp
server.logout("Alice");
```

* This line:

```cpp
sessions.erase("Alice");
```

removes Alice’s session from the map.

* Now `sessions = { }` (empty).
* Output:

```
Alice logged out.
```

---

4. **Action: Update Profile (after logout)**

```cpp
server.action("Alice", "Update Profile");
```

* The code checks again:

```cpp
if (sessions.find("Alice") != sessions.end())
```

❌ This time `"Alice"` does **not exist** in the map (because she logged out).

* So it goes to the `else` branch:

```
No active session for Alice
```

---

### ✅ Why does it fail?

Because the `StatefulServer` class **removes Alice’s session data on logout**. After logging out, the server no longer remembers Alice. So when she tries to perform `"Update Profile"`, the server says:
👉 *"No active session for Alice"*

This is exactly how **stateful systems work** in real life:

* When you **log out** of Facebook and try to refresh your profile, the server doesn’t let you because your **session expired**.

---

⚡ In short:

* Before logout → server remembers Alice → actions succeed.
* After logout → server forgets Alice → actions fail.

---

## 6. When to Use What?

| Factor               | Stateless                        | Stateful                    |
| -------------------- | -------------------------------- | --------------------------- |
| **Scalability**      | ✅ Easy (just add servers)        | ❌ Hard (need to sync state) |
| **Performance**      | ✅ Fast (lightweight)             | ⚠️ Slower (session mgmt)    |
| **Use Case**         | APIs, CDNs, Authentication       | Games, Banking, Chats       |
| **Failure Handling** | ✅ Easy (route to another server) | ❌ Hard (must recover state) |

---

## 7. Hybrid Approach (Best in Real World)

Most real-world systems use a **mix of stateless + stateful**:

* **Frontend**: Stateless (e.g., REST API, load balanced servers).
* **Backend**: Stateful (e.g., database, caching session info).
* Example:

  * Amazon shopping: browsing is **stateless**, but your **cart** is **stateful**.
  * Google Docs: editing is **stateful**, but serving static assets is **stateless**.

---

## 8. Key Takeaways

* **Stateless** → Simpler, more scalable, resilient.
* **Stateful** → Needed for personalization, consistency, multi-step workflows.
* **Best Systems** → Combine both depending on context.

**